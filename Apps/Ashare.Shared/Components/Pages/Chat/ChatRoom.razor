@page "/chat/{ChatId:guid}"
@using System.Text.Json
@using ACommerce.Client.Auth
@using ACommerce.Client.Chats
@using ACommerce.Client.Profiles
@using ACommerce.Client.Realtime
@using Ashare.Shared.Services
@using Microsoft.JSInterop
@inject ChatsClient ChatsClient
@inject ProfilesClient ProfilesClient
@inject RealtimeClient RealtimeClient
@inject TokenManager TokenManager
@inject IAppNavigationService Navigation
@inject ILocalizationService L
@inject ITimezoneService Timezone
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="ac-page ashare-chatroom-page">
    @* Chat Header *@
    <div class="ashare-chatroom-header">
        <button class="ashare-back-btn" @onclick="() => Navigation.NavigateBack()">
            <i class="bi bi-arrow-right"></i>
        </button>
        <div class="ashare-chat-user">
            <div class="ashare-chat-avatar-sm">
                @if (!string.IsNullOrEmpty(_chat?.Avatar))
                {
                    <img src="@_chat.Avatar" alt="" />
                }
                else
                {
                    <i class="bi bi-person-circle"></i>
                }
            </div>
            <div class="ashare-chat-user-info">
                <h3>@_chat?.Name</h3>
                <span class="@(_isOnline ? "online" : "")">
                    @(_isOnline ? L["Online"] : L["Offline"])
                </span>
            </div>
        </div>
        <button class="ashare-chat-menu">
            <i class="bi bi-three-dots-vertical"></i>
        </button>
    </div>

    @* Messages *@
    <div class="ashare-messages-container" @ref="_messagesContainer">
        @if (_isLoading)
        {
            <div class="ashare-loading">
                <div class="ac-spinner"></div>
            </div>
        }
        else if (_messages.Count == 0)
        {
            <div class="ashare-chat-empty">
                <i class="bi bi-chat-text"></i>
                <p>@L["NoMessagesYet"]</p>
                <span class="ashare-chat-hint">@L["SendFirstMessage"]</span>
            </div>
        }
        else
        {
            @foreach (var message in _messages)
            {
                <div class="ashare-message @(message.IsMine ? "mine" : "theirs")">
                    <div class="ashare-message-bubble">
                        @if (message.Type == "image")
                        {
                            <img src="@message.Content" alt="" class="ashare-message-image" />
                        }
                        else
                        {
                            <p>@message.Content</p>
                        }
                        <span class="ashare-message-time">
                            @GetFormattedTime(message.Id, message.SentAt)
                            @if (message.IsMine)
                            {
                                <i class="bi @(message.IsRead ? "bi-check-all" : "bi-check")"></i>
                            }
                        </span>
                    </div>
                </div>
            }

            @if (_isTyping)
            {
                <div class="ashare-message theirs">
                    <div class="ashare-typing-indicator">
                        <span></span><span></span><span></span>
                    </div>
                </div>
            }
        }
    </div>

    @* Input *@
    <div class="ashare-chat-input">
        <button class="ashare-attach-btn">
            <i class="bi bi-paperclip"></i>
        </button>
        <input type="text"
               class="ac-input"
               placeholder="@L["TypeMessage"]"
               @bind="_newMessage"
               @bind:event="oninput"
               @onkeyup="HandleKeyUp" />
        <button class="ashare-send-btn"
                @onclick="SendMessage"
                disabled="@string.IsNullOrWhiteSpace(_newMessage)">
            <i class="bi bi-send-fill"></i>
        </button>
    </div>
</div>

@code {
    [Parameter]
    public Guid ChatId { get; set; }

    private ChatInfo? _chat;
    private List<ChatMessage> _messages = new();
    private string _newMessage = "";
    private bool _isLoading = true;
    private bool _isOnline = false;
    private bool _isTyping = false;
    private ElementReference _messagesContainer;
    private IDisposable? _messageSubscription;
    private string? _currentUserId;
    private bool _shouldScrollToBottom = true;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            // Load chat info
            var chat = await ChatsClient.GetConversationAsync(ChatId);

            // ØªØ¹ÙŠÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø£ÙˆÙ„ÙŠØ©
            var otherPartyId = chat?.OtherPartyId;
            var displayName = "Ù…Ø³ØªØ®Ø¯Ù…";
            string? avatar = chat?.OtherPartyAvatar;

            // Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù…Ù† Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„
            if (!string.IsNullOrEmpty(otherPartyId))
            {
                try
                {
                    var profile = await ProfilesClient.GetByUserIdAsync(otherPartyId);
                    if (profile != null)
                    {
                        displayName = profile.FullName ?? profile.BusinessName ?? "Ù…Ø³ØªØ®Ø¯Ù…";
                        avatar = profile.Avatar ?? avatar;
                    }
                }
                catch
                {
                    // Ø¥Ø°Ø§ ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„Ø¨Ø±ÙˆÙØ§ÙŠÙ„ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ
                }
            }

            _chat = new()
            {
                Avatar = avatar ?? "",
                Id = chat?.Id ?? Guid.Empty,
                Name = displayName
            };

            // Load messages
            var messages = await ChatsClient.GetMessagesAsync(ChatId);

            // Get current user ID to calculate IsMine correctly
            _currentUserId = TokenManager.GetUserIdFromToken();

            _messages = messages?
            .Select(message =>
            new ChatMessage
            {
                Content = message.Content,
                Id = message.Id,
                IsFailed = false,
                // Calculate IsMine by comparing SenderId with current user ID
                IsMine = !string.IsNullOrEmpty(_currentUserId) && message.SenderId == _currentUserId,
                IsRead = message.IsRead,
                SentAt = message.SentAt,
                Type = message.Type
            })
            .ToList() ?? [];

            // Subscribe to real-time updates (connect to chat hub with auth token)
            var accessToken = await TokenManager.GetTokenAsync();
            await RealtimeClient.ConnectAsync("Marketplace", "/hubs/chat", accessToken);

            // Join the chat group to receive messages for this conversation
            await RealtimeClient.SendAsync("JoinChat", ChatId.ToString());

            // Subscribe to "ReceiveMessage" event (the method name on IChatClient)
            // Server calls: client.ReceiveMessage("MessageReceived", message)
            _messageSubscription = RealtimeClient.On<string, object>("ReceiveMessage", HandleNewMessage);

            // Mark as read
            await ChatsClient.MarkAsReadAsync(ChatId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ChatRoom] Error loading chat: {ex.Message}");
        }
        finally
        {
            _isLoading = false;
        }
    }

    private void HandleNewMessage(string method, object messageData)
    {
        try
        {
            Console.WriteLine($"[ChatRoom] ðŸ“© Received event: method={method}");

            // Only process MessageReceived events
            if (method != "MessageReceived") return;

            // Parse the incoming message
            var json = messageData?.ToString();
            Console.WriteLine($"[ChatRoom] ðŸ“© Message data: {json?.Substring(0, Math.Min(100, json?.Length ?? 0))}...");

            if (string.IsNullOrEmpty(json)) return;

            var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
            var incomingMessage = JsonSerializer.Deserialize<IncomingMessage>(json, options);

            if (incomingMessage == null) return;

            // Check 1: Exact ID match (message already processed)
            if (_messages.Any(m => m.Id == incomingMessage.Id))
            {
                Console.WriteLine($"[ChatRoom] â­ï¸ Skipping duplicate message (ID match): {incomingMessage.Id}");
                return;
            }

            // Determine if this message is from the current user
            var isMine = !string.IsNullOrEmpty(_currentUserId) && incomingMessage.SenderId == _currentUserId;

            // Check 2: For messages from current user, check for pending local message with same content
            // This handles the race condition where SignalR arrives before API response updates the local ID
            if (isMine)
            {
                var pendingMessage = _messages.FirstOrDefault(m =>
                    m.IsMine &&
                    m.Content == incomingMessage.Content &&
                    Math.Abs((m.SentAt - incomingMessage.CreatedAt).TotalSeconds) < 30);

                if (pendingMessage != null)
                {
                    // Update the pending message's ID with the server ID instead of adding duplicate
                    Console.WriteLine($"[ChatRoom] ðŸ”„ Updating pending message ID: {pendingMessage.Id} â†’ {incomingMessage.Id}");
                    pendingMessage.Id = incomingMessage.Id;
                    pendingMessage.SentAt = incomingMessage.CreatedAt;
                    InvokeAsync(StateHasChanged);
                    return;
                }
            }

            Console.WriteLine($"[ChatRoom] âœ… Adding new message: {incomingMessage.Content} (IsMine: {isMine})");

            var chatMessage = new ChatMessage
            {
                Id = incomingMessage.Id,
                Content = incomingMessage.Content,
                Type = incomingMessage.Type?.ToString()?.ToLower() ?? "text",
                IsMine = isMine, // Could be from current user on another device
                IsRead = false,
                SentAt = incomingMessage.CreatedAt
            };

            _messages.Add(chatMessage);
            _shouldScrollToBottom = true;

            InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ChatRoom] Error handling new message: {ex.Message}");
        }
    }

    // DTO for incoming real-time messages
    private class IncomingMessage
    {
        public Guid Id { get; set; }
        public Guid ChatId { get; set; }
        public string SenderId { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public object? Type { get; set; }
        public DateTime CreatedAt { get; set; }
    }

    private async Task HandleKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(_newMessage))
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(_newMessage)) return;

        var message = new ChatMessage
        {
            Id = Guid.NewGuid(),
            Content = _newMessage,
            Type = "text",
            IsMine = true,
            SentAt = DateTime.UtcNow // Use UTC for storage/transmission
        };

        _messages.Add(message);
        var messageToSend = _newMessage;
        _newMessage = "";
        _shouldScrollToBottom = true;

        try
        {
            var response = await ChatsClient.SendMessageAsync(ChatId, new SendMessageRequest
            {
                Content = messageToSend,
                Type = "text"
            });

            // Update local message with server-assigned ID
            // This ensures the duplicate check works when SignalR broadcast arrives
            if (response != null)
            {
                Console.WriteLine($"[ChatRoom] âœ… Message sent, updating ID from {message.Id} to {response.Id}");
                message.Id = response.Id;
                message.SentAt = response.CreatedAt;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ChatRoom] âŒ Failed to send message: {ex.Message}");
            // Handle send failure
            message.IsFailed = true;
        }

        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        _messageSubscription?.Dispose();

        // Leave the chat group before disconnecting
        try
        {
            await RealtimeClient.SendAsync("LeaveChat", ChatId.ToString());
        }
        catch { /* Ignore errors when leaving */ }

        await RealtimeClient.DisconnectAsync();
    }

    // Cache for formatted times to avoid blocking renders
    private Dictionary<Guid, string> _formattedTimes = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Scroll to bottom when needed
        if (_shouldScrollToBottom && !_isLoading)
        {
            _shouldScrollToBottom = false;
            await ScrollToBottomAsync();
        }

        if (firstRender || _messages.Any(m => !_formattedTimes.ContainsKey(m.Id)))
        {
            // Format all message times using timezone service
            foreach (var message in _messages.Where(m => !_formattedTimes.ContainsKey(m.Id)))
            {
                var formattedTime = await Timezone.FormatTimeAsync(message.SentAt, "HH:mm");
                _formattedTimes[message.Id] = formattedTime;
            }
            StateHasChanged();
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("eval", "document.querySelector('.ashare-messages-container')?.scrollTo(0, document.querySelector('.ashare-messages-container')?.scrollHeight || 0)");
        }
        catch { /* Ignore scroll errors */ }
    }

    private string GetFormattedTime(Guid messageId, DateTime sentAt)
    {
        if (_formattedTimes.TryGetValue(messageId, out var formatted))
            return formatted;
        return sentAt.ToString("HH:mm"); // Fallback to raw time
    }

    // DTOs
    public class ChatInfo
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = "";
        public string? Avatar { get; set; }
    }

    public class ChatMessage
    {
        public Guid Id { get; set; }
        public string Content { get; set; } = "";
        public string Type { get; set; } = "text";
        public bool IsMine { get; set; }
        public bool IsRead { get; set; }
        public bool IsFailed { get; set; }
        public DateTime SentAt { get; set; } // Stored in UTC
    }
}
